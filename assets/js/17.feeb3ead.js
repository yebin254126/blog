(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{502:function(s,t,a){"use strict";a.r(t);var n=a(4),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("hr"),s._v(" "),a("p",[s._v("title: String 的详解\ndate: 2017-12-15\ntags:")]),s._v(" "),a("ul",[a("li",[s._v("tag1\ncategories:")]),s._v(" "),a("li",[s._v("java")])]),s._v(" "),a("hr"),s._v(" "),a("h2",{attrs:{id:"java-string的详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-string的详解"}},[s._v("#")]),s._v(" Java String的详解")]),s._v(" "),a("p",[s._v("String是java语言中使用最为频繁的数据类型之一，几乎在各种 场景中都能见到它，但你真的了解String 吗？下面我就带领大家详细的认识一下String.")]),s._v(" "),a("p",[s._v("1、String到底是引用类型还是基本类型")]),s._v(" "),a("p",[s._v('​        相信大家学java的时候都遇到这个问题，String 是基本类型呢，还是引用类型呢？我们都知道创建String类型的变量有两种方式。一种像创建基本类型的变量一样直接赋值，如String s="abc",另一种则是和创建对象一样使用new关键字创建，如String str=new String("abc").那么问题就来了，既然String 可以像基本类型的变量一样创建也可以像引用类型的变量一样创建，那么它究竟是基本类型的变量还是引用类型的变量呢？其实String是引用类型的，所谓的用”=“创建其实是Jvm做了一些优化。但使用=和new两种方式创建String对象的方式不同。下面来看一段代码。')]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" s1"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"abc"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" s2"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"abc"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" s3"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"abc"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" s4"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"abc"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("s1"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v("s2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("s1"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v("s3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("s3"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v("s4"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("要说清楚这其中的原因就不得不讲一下java内存模型了：")]),s._v(" "),a("p",[a("img",{attrs:{src:"C:%5CUsers%5C98262%5CAppData%5CLocal%5CTemp%5C1567216840821.png",alt:"1567216840821"}})]),s._v(" "),a("p",[s._v("如图所示：JMM分为4大块、即堆、栈、方法区和本地方法区。")]),s._v(" "),a("p",[s._v("堆：此区域用于存放实例对象、几乎所有对象的实例都在这里分配。")]),s._v(" "),a("p",[s._v("栈：线程私有，用于存放方法执行时产生的栈帧，即存放局部变量表、操作数栈、程序计数器、方法出口和动态链接等")]),s._v(" "),a("p",[s._v("方法区：用于存放class信息、当jvm把class文件加载后就存放于此区域。")]),s._v(" "),a("p",[s._v("本地方法区：用于查找本地方法（native方法,C/C++写的，依赖与操作系统）")]),s._v(" "),a("p",[s._v("接下来还要引入一个重要的概念：常量池")]),s._v(" "),a("p",[s._v("常量池：用于保存常量数据")]),s._v(" "),a("p",[s._v("下面就来解释上面的代码：由于通过字面量创建字符串对象的时候、先检查常量池中时候有该字符串常量，如果有直接引用该变量，否则先将其放入常量池中再去引用它，如下图所示：")]),s._v(" "),a("p",[a("img",{attrs:{src:"C:%5CUsers%5C98262%5CAppData%5CLocal%5CTemp%5C1567218725247.png",alt:"1567218725247"}})]),s._v(" "),a("p",[s._v("因此s1和s2引用同一内存空间，故s1==s2。但是使用new 创建对象就不一样了，通过new 创建对象的时候，先检查常量池中是否有该字符串，如果有则在堆里开辟一块内存空间然后将该字符串拷贝一份过来，然后将新开辟出来的地址给引用变量，如果常量池中没有该字符串则先把该字符串放入常量池中，然后再在堆里开辟一块内存空间并把该字符串拷贝一份过来，然后将地址引用给它，如图所示：")]),s._v(" "),a("p",[a("img",{attrs:{src:"C:%5CUsers%5C98262%5CAppData%5CLocal%5CTemp%5C1567219582189.png",alt:"1567219582189"}})]),s._v(" "),a("p",[s._v("所以、s3和s4是存放于堆里的、并且处于不同的空间，而s1和s2是处于常量池中，引用的是同一地址。另外，在JDK7之后常量池转移到堆中。")]),s._v(" "),a("p",[s._v("2、字符串的不可变性")]),s._v(" "),a("p",[s._v("在jdk源码中关于String类有这么一段描述,"),a("img",{attrs:{src:"C:%5CUsers%5C98262%5CAppData%5CLocal%5CTemp%5C1567220779721.png",alt:"1567220779721"}})]),s._v(" "),a("p",[s._v("中文意思大概是字符串是常量，他们的值在创建后就不能被改变，那么，为什么字符串为什么是不可变的呢？")]),s._v(" "),a("p",[s._v("​\tString 对象是final类，不可再被其他的类继承。String类的内容其实是char数组保存的，并且其value是被final修饰的，故不能再去引用其他对象。但是这仅仅只能保证value不去指向其他对象，value本身的值是可以修改的，但好在String类中的所有方法都没有修改value的值，故保证了String的不可变性。"),a("img",{attrs:{src:"C:%5CUsers%5C98262%5CAppData%5CLocal%5CTemp%5C1567241486860.png",alt:"1567241486860"}})]),s._v(" "),a("p",[s._v("​      另外，String设计成不可变的有一下原因：")]),s._v(" "),a("ul",[a("li",[s._v("节约内存空间：我们都知道不管通过什么方式创建String对象的时候都会去检查常量池中是否有该对象，如果没有就将其放在常量池中，然后再引用它，否则直接引用了它，避免了重复创建，节约内存空间")]),s._v(" "),a("li",[s._v("安全性：由于String经常作为用户名和密码，如何可变将导致安全隐患。另外，设计成不可变也保证了线程的安全性")])])])}),[],!1,null,null,null);t.default=r.exports}}]);